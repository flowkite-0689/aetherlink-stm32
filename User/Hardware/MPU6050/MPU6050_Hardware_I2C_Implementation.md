# MPU6050 Hardware I2C Implementation for STM32F103C8T6

## Overview
This document describes the hardware I2C implementation for interfacing MPU6050 6-axis motion tracking device with STM32F103C8T6 microcontroller using I2C1 peripheral (PB6=SCL, PB7=SDA).

## I2C Communication Protocol

### Basic Principles
I2C (Inter-Integrated Circuit) is a synchronous, multi-master, multi-slave serial communication bus that uses two wires:
- **SCL (Serial Clock Line)**: Clock signal generated by the master
- **SDA (Serial Data Line)**: Bidirectional data line

### Communication Sequence
1. **START Condition**: SDA goes low while SCL is high
2. **Address Frame**: 7-bit slave address + R/W bit (0=Write, 1=Read)
3. **Data Frames**: 8-bit data bytes with ACK/NACK
4. **STOP Condition**: SDA goes high while SCL is high

### MPU6050 I2C Address
- **0x68** when AD0 pin is grounded
- **0x69** when AD0 pin is connected to VCC

## Hardware Configuration

### Pin Mapping
| STM32F103C8T6 | MPU6050 | Function |
|--------------|---------|----------|
| PB6          | SCL     | Clock    |
| PB7          | SDA     | Data     |
| 3.3V         | VCC     | Power    |
| GND          | GND     | Ground   |

### External Pull-up Resistors
Both SCL and SDA lines require external 4.7kΩ pull-up resistors to 3.3V:
```
PB6 (SCL) ---- 4.7kΩ ---- 3.3V
PB7 (SDA) ---- 4.7kΩ ---- 3.3V
```

## Implementation Details

### 1. I2C Initialization (`MPU6050_I2C_Init()`)

**Clock Configuration:**
- GPIOB and AFIO clocks enabled via RCC_APB2PeriphClockCmd
- I2C1 clock enabled via RCC_APB1PeriphClockCmd

**GPIO Configuration:**
- PB6 and PB7 configured as Alternate Function Open Drain
- GPIO_Speed_50MHz for standard mode operation

**I2C Parameters:**
- Mode: I2C_Mode_I2C
- Duty Cycle: I2C_DutyCycle_2 (standard mode)
- Clock Speed: 400kHz (standard mode)
- ACK: Enabled
- Address Mode: 7-bit

### 2. Event-Based Communication

The implementation uses STM32's hardware I2C events for reliable communication:

#### Write Operation Sequence:
1. **EV5**: Master mode selected after START
2. **EV6**: Transmitter mode selected after address transmission
3. **EV8_1**: Byte transmitting after data sent
4. **EV8_2**: Byte transmitted (ready for next byte or STOP)

#### Read Operation Sequence:
1. **EV5**: Master mode selected after START
2. **EV6**: Transmitter mode selected for register address
3. **EV8_2**: Register address transmitted
4. **EV5**: Repeated START condition
5. **EV6**: Receiver mode selected
6. **EV7**: Byte received

### 3. Key Functions

#### `MPU6050_WaitEvent(I2Cx, I2C_EVENT)`
- Waits for specific I2C events with timeout
- Returns 0 on success, 1 on timeout
- Essential for reliable communication

#### `MPU6050_WriteReg(RegAddress, Data)`
- Writes single byte to specified register
- Handles complete write sequence with error recovery

#### `MPU6050_ReadReg(RegAddress)`
- Reads single byte from specified register
- Implements repeated START for read operations
- Returns 0xFF on error

#### `MPU6050_ReadBytes(RegAddress, len, pData)`
- Reads multiple bytes starting from specified register
- Handles ACK/NACK for multi-byte reads
- Returns 0 on success, 1 on error

## Code Structure

### Header Files
- `hardware_i2c.h`: Hardware I2C function declarations
- `MPU6050_hardware_i2c.h`: MPU6050 register definitions and hardware I2C interface

### Source Files
- `hardware_i2c.c`: Hardware I2C implementation
- `MPU6050.c`: MPU6050 driver functions (unchanged logic, uses hardware I2C)

## Usage Example

```c
#include "MPU6050_hardware_i2c.h"

int main(void) {
    // Initialize system clocks and delays
    SystemInit();
    delay_init();
    
    // Initialize MPU6050 hardware I2C
    MPU6050_IIC_Init();
    
    // Initialize MPU6050 sensor
    if(MPU_Init() == 0) {
        // Success - device ID verified
        
        while(1) {
            short ax, ay, az, gx, gy, gz;
            
            // Read accelerometer data
            MPU_Get_Accelerometer(&ax, &ay, &az);
            
            // Read gyroscope data
            MPU_Get_Gyroscope(&gx, &gy, &gz);
            
            delay_ms(100); // 10Hz sampling rate
        }
    } else {
        // Error - handle initialization failure
    }
}
```

## Important Notes

### 1. Clock Configuration
- I2C1 is on APB1 bus (max 36MHz)
- Ensure system clock configuration provides sufficient frequency
- 400kHz standard mode requires proper clock settings

### 2. Pull-up Resistors
- **Critical**: External pull-ups are mandatory
- Without pull-ups, I2C communication will fail
- Typical values: 4.7kΩ to 10kΩ

### 3. Error Handling
- Functions include timeout mechanisms
- Error recovery via STOP condition generation
- Check return values for error detection

### 4. Performance Considerations
- Hardware I2C is faster and more reliable than software I2C
- DMA can be implemented for high-speed data transfer
- Interrupt-driven operation possible for better CPU utilization

## Troubleshooting

### Common Issues
1. **No Communication**: Check pull-up resistors and power supply
2. **Timeout Errors**: Verify clock configuration and bus speed
3. **Wrong Device ID**: Check AD0 pin connection and I2C address
4. **Bus Stuck**: Reset I2C peripheral or generate STOP condition

### Debugging Tips
- Use logic analyzer to monitor SCL/SDA signals
- Verify signal levels and timing
- Check for bus contention or wiring issues

## Advantages of Hardware I2C

1. **Reliability**: Hardware handles timing and protocol
2. **Performance**: Faster than software implementation
3. **CPU Efficiency**: Frees up CPU for other tasks
4. **Error Handling**: Built-in error detection and recovery
5. **Standard Compliance**: Guaranteed I2C protocol compliance

This implementation provides a robust and efficient hardware I2C interface for MPU6050 integration with STM32F103C8T6 microcontrollers.